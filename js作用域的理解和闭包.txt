学习地址链接：https://blog.csdn.net/whd526/article/details/70990994


作用域首先分为两个部分：全局作用域和局部作用域。
	全局作用域：在代码任何地方都可以访问到的变量和函数保存在全局作用域中。
	局部作用域：在函数内部声明的变量和函数保存在函数的局部作用域中。

变量提升：
	javascript的一个特点，只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”（即解析函数时在函数作用域内进行变量提升）

https://blog.csdn.net/qappleh/article/details/80311443
	js的执行环境：js为每一个执行环境关联了一个变量对象（即活动对象）。环境中定义的所有变量和函数都保存在这个对象中。 
	全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。 
	js的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境的变量对象就被压入一个环境栈中。而在函数执行之后，栈将该函数的变量对象弹出，
把控制权交给之前的执行环境变量对象。 
	当某个环境中的所有代码执行完毕后，该环境被销毁（弹出环境栈），保存在其中的所有变量和函数也随之销毁（全局执行环境变量直到应用程序退出，如网页关闭才会被销毁）
	js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。

作用域链：
      当某个函数第一次被调用时，就会创建一个执行环境(execution context)以及相应的作用域链，并把作用域链赋值给一个特
殊的内部属性([scope])。然后使用this，arguments(arguments在全局环境中不存在)和其他命名参数的值来初始化函数的活动
对象(activation object)。当前执行环境的变量对象始终在作用域链的第0位。 

javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。"链式作用
域"结构（chain scope）

闭包的概念：
	闭包就是能够读取其他函数内部变量的函数。
	闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。
	内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包。

闭包中的this理解：
	this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。
不过，匿名函数具有全局性，因此this对象同常指向window

闭包的应用场景：
1.用闭包模拟私有方法（封装相关的功能集）
2.采用函数引用方式的setTimeout调用
3.将函数关联到对象的实例方法
模拟私有变量：
function Counter(start){
var count = start;
　　return{
　　increment:function(){
　　count++;
　　},
　　get:function(){
　　return count;
　　}
　　}
　　}
　　var foo =Counter(4);
　　foo.increment();
　　foo.get();// 5
1、保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安
全性。
2、在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c（），都会给i自加1。

闭包的原理：
     闭包是指有权访问另一个函数作用域中的变量的函数。根据下面的代码示例来理解什么是闭包，在add函数内部的匿名函数中，
访问到外部函数的变量outerArg，在执行add(10)之后外部函数返回了，并且将内部的匿名函数赋值给了变量addTen，此时通
过addTen调用函数，依然可以访问到outerArg，也就是10。这个闭包中的变量，只能通过调用addTen函数访问，无法通过其
他渠道访问到，下面代码最后一行通过输出属性的方式尝试访问结果是输出undefined。outerArg是属于add函数的作用域中的
变量，addTen有权访问add函数作用域中的变量，因此addTen是一个闭包。闭包产生的本质是：在一个函数(外部函数)内部定
义的函数(内部函数)会将外部函数作用域中的活动对象添加到自己的作用域链中，下面代码中inner函数将add函数的outerArg添
加到自己的作用域链上。在add函数执行完之后，其执行环境会被销毁，但由于inner函数还在引用outerArg，所以outerArg不
会被销毁，依然保留在inner函数的作用域链中。直到inner函数(addTen函数)被销毁之后，outerArg才会跟着其作用域链一起
被销毁。由于闭包变量是位于作用域链上，因此必须调用闭包函数进入其作用域之后才能访问到闭包变量。
function add(outerArg) {
  function inner(innerArg) {
    return innerArg + outerArg;
  }
  return inner;
}
var addTen = add(10);
console.log(addTen(1)); // 输出11
console.log(addTen(2)); // 输出12
console.log(addTen(3)); // 输出13
console.log(addTen.outerArg); // undefined